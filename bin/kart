const inquirer = require('inquirer'),
      yargs = require('yargs'),
      package = require('../package.json'),
      kart = require('../lib'),
      colors = require('colors'),
      gitRev = require('git-rev-sync'),
      fs = require('fs');
      path = require('path');

function selectProject() {
    let projects,
        project,
        channel;

    return kart.getProjects()
        .then((p) => {
            projects = p;
            let choices = Object.keys(projects),
                dir = path.basename(process.cwd());

            return inquirer.prompt([{
                type: 'list',
                name: 'project',
                message: 'Which project',
                paginated: true,
                choices: choices,
                default: choices.indexOf(dir) >= 0 ? dir : null
            }]);
        }).then(answers => {
            project = answers.project;

            return inquirer.prompt([{
                type: 'list',
                name: 'channel',
                message: 'Which channel',
                paginated: true,
                choices: Object.keys(projects[project].channels)
            }]);
        }).then(answers => {
            channel = answers.channel;

            return kart.status(project, channel);
        }).then((s) => {
            return {
                name: project,
                channel,
                status: s
            };
        });
}

function _zeroPad(v) {
    return ('0' + v).slice(-2);
}

function _formatDate(d) {
    return `${_zeroPad(d.getDate())}/${_zeroPad(d.getMonth() + 1)}/${d.getFullYear()} ` +
           `${_zeroPad(d.getHours())}:${_zeroPad(d.getMinutes())}:${_zeroPad(d.getSeconds())}`
}

function printStatus(project, channel, release) {
    console.log();
    console.log(`Current ${channel.cyan} release of ${project.cyan}:`);
    
    if (release) {
        console.log(`    Version:  ` + `${release.buildVersion}`.yellow);
        if (release.metadata.revision) {
            console.log(`    Commit:   ` + `${release.metadata.revision}`);
        } else {
            console.log(`    Commit:   ` + `???`.gray);
        }
        console.log(`    Built:    ${_formatDate(release.buildDate)}`);
        console.log(`    Deployed: ${_formatDate(release.releaseDate)}`);
    } else {
        console.log(`    Version:  ` + `unknown`.red);
        console.log(`    Commit:   ` + `???`.gray);
        console.log(`    Built:    ` + `???`.gray);
        console.log(`    Deployed: ` + `???`.gray);
    }
    console.log();
}

// ----

function release(argv) {
    let project;

    return selectProject().then((p) => {
            project = p;

            printStatus(project.name, project.channel, project.status);

            return kart.archive.list(project.name, project.channel, {
                sort: {
                    key: 'buildDate',
                    order: -1
                }
            });
        }).then((builds) => {
            let choices = builds.map((build) => {
                let choice = {
                    name: `${build.buildVersion} (${_formatDate(build.buildDate)})`,
                    value: build
                };

                if (project.status &&
                    project.status.version === build.version &&
                    project.status.number === build.number) {

                    choice.name += ' (current)'.yellow;
                }

                return choice;
            });

            if (choices.length > 0) {
                choices[0].name += ' (latest)'.gray
            }

            return inquirer.prompt([{
                type: 'list',
                name: 'build',
                message: 'Pick a build to deploy',
                paginated: true,
                choices: choices
            }]);
        }).then(answers => {
            build = answers.build;

            return build.fetchMetadata();
        }).then(() => {
            console.log('');
            console.log(`Build details`);
            console.log(`    Version: ${build.buildVersion.yellow}`);

            if (build.metadata.revision) {
                console.log(`    Commit:  ${build.metadata.revision}`);
            }

            console.log(`    Built:   ${_formatDate(build.buildDate).cyan}`);
            console.log('');

            return inquirer.prompt([{
                type: 'confirm',
                name: 'proceed',
                message: `All good?`,
                default: false
            }]);
        }).then(answers => {
            if (answers.proceed) {
                console.log(`Deploying ${build.project.cyan} ${build.buildVersion.yellow} to ${build.channel.cyan}`);
                return kart.release(build);
            } else {
                console.log('Aborted');
                return;
            }
        });
}

function status(argv) {
    return selectProject().then((p) => {
        printStatus(p.name, p.channel, p.status);
    });
}

// ----

function archive(argv) {
    let build,
        packagejsonPath = './' + path.normalize(argv.fromRepo + '/package.json'),
        packagejson,
        name,
        version,
        metadata;

    if (argv.fromRepo) {
        try {
            packagejson = JSON.parse(fs.readFileSync(packagejsonPath, 'utf8'));
            name = packagejson.name;
            version = packagejson.version;
        } catch (err) {}

        metadata = {
            revision: gitRev.long(argv.fromRepo)
        };
    }

    name = argv.name ? argv.name : name;
    version = argv.version ? argv.version : version;

    return kart.archive.store(argv.buildDir, name, argv.channel, version, null, argv.arch, metadata)
        .then((b) => {
            build = b;

            console.log(build.publicUrl);

            if (argv.release) {
                return kart.release(build);
            }
        });
}

// ----

let argv = yargs
    .command('release', 'deploy a new release of a project', () => {}, (argv) => {
        console.log('kart: Making a release');
        release(argv).catch((err) => {
            console.log(err);
        });
    })
    .command('status', 'show current deployments for a project', () => {}, (argv) => {
        console.log('kart: Showing status for channel');
        status(argv).catch((err) => {
            console.log(err);
        });
    })
    .command('archive <build-dir>', 'archive a build', {
        'from-repo': {
            alias: 'r',
            describe: 'path to repository related to the build (for autodetecting params)',
            type: 'string'
        },
        'name': {
            describe: 'set project name (or override autodetected one)',
            type: 'string'
        },
        'version': {
            describe: 'set project version (or override autodetected one)',
            type: 'string'
        },
        'revision': {
            describe: 'set project revision (or override autodetected one)',
            type: 'string'
        },
        'arch': {
            describe: 'set build arch (defaults to all)',
            type: 'string',
            default: 'all'
        },
        'channel': {
            alias: 'c',
            describe: 'build to be archived',
            type: 'string',
            demandOption: true
        },
        'archive-root': {
            describe: 'override archive root bucket',
            type: 'string',
            alias: 'a'
        },
        'release': {
            describe: 'release after archiving',
            type: 'boolean'
        }
    }, (argv) => {
        if (argv.archiveRoot) {
            return kart.configure({
                rootBucket: {
                    name: argv.archiveRoot
                }
            }).then(() => {
                    return archive(argv);
                });
        } else {
            return archive(argv);
        }
    })
    .help()
    .argv;